
# Midterm Exam

- One week from today
- Here
- On paper
- Bring a pencil, any paper notes you want, a dedicated non-internet
  calculator if you have one, water bottle.
- On monday: Topic Review

## Today: The rest of a CPU

Pieces we have:

- An adder circuit
- Subtracter circuit (A - B)
  - Two's complement B
  - Then just add
- A device that can store a number: A Register
  - It's a bunch of D flip-flips
- For today's CPU, lets say "a number" is 16 bits

We need:

- An Arithmetic Logic Unit
  - Three inputs:
    - A
    - B
    - An operation code that decides what to do with
      A and B, e.g. add, subtract, multiply, divide,
      negate (two's complement), etc.
  - One output
- A Register File
  - This is a bunch of registers (say, 8 of them)
  - Circuitry to select one active register
  - Circuitry to select read or write (3 bit input)
  - And then lines to input or output (one number in or out)
- A Memory
  - This is like a really big register file, with
    like 64k or a million "registers".
  - Let's go with 16k, since that's less than 2^16.
  - Typically addressed in bytes, not 16 bit values,
    but either works.
- Control unit
  - Forever, it:
  - Reads one instruction from memory (our instruction is
    a single 16 bit number)
  - The memory address it reads the instruction from is
    whatever address is in the Program Counter register.
  - Execute that instruction
  - Increment the program counter (to next instruction)
  - Repeat

## Executing an instruction

- It's a 16-bit number, e.g: {000}{0 000}{0 00}{00 1}{010}
- Figure out what kind of instruction it is:
  - (maybe) First 3 bits specify instruction type.
    - bits 000 means arithmetic instruction
- Decode the instruction, for arithmetic:
  - Next 4 bits is what operation (0000 is add)
    - Extensions, maybe:
      - 0001 is subtract
      - 0010 is multiply
      - etc
  - Next 3 bits is input register A (r0)
  - Next 3 bits is input register B (r1)
  - Next 3 bits is input output register (r2)
- We get ADD r0 + r1 => r2


## The computer is all built

- We have a keypad that lets us enter a hexidecimal
  number directly into register 0.
- We can see the current value of register 0, it's hooked
  up to a (hex) 4 digit 7-segment display.
- Then we've got a "run" button which runs the stored program
  from RAM.
- The output is whatever ends up in r0.

Here's our stored program, as pseudocode:

```
# Counts the one bits in the input
r1 = 0
while r0 > 0:
  if r0 & 1 != 0:
    r1 += 1
  r0 = r0 / 2
r0 = r
```

```
# Counts the one bits in the input
r1 = 0
r2 = 0
r3 = 1
r4 = 2
while r0 > r2:
  if r0 & r3 != r2:
    r1 += r3
  r0 = r0 / r4
r0 = r
```

New instruction type, conditional jump:

- type 001
- operation 0000 is "jump if greater"
- 3 bits: input A
- 3 bits: input B
- 3 bits: destination address







